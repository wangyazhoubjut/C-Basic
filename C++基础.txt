const: 修饰变量，说明该变量不可以被改变
       修饰指针，指向常量的指针、和自身是常量的指针  const后面的值不可以改变
	              const char* p2 = greeting;// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
                  char* const p3 = greeting;// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
	   修饰参数， 传递过来的参数在函数体内不可改变
	   修饰成员函数，不得修改类中的任何数据变量的值
static 修饰普通变量，修改变量的存储区域和生命周期，使得变量存储在静态区；main函数运行前分配了空间，系统有默认值初始化它。
       修饰普通函数  表面函数的作用范围、仅在定义该函数的文件内才能使用
	   修饰成员变量  所有对象只保存一个该变量，不需要生成对象就可以访问该成员
	   修饰成员函数 不需要生成对象就可以访问该函数，但是static函数内不能访问非静态成员，本质是和全局函数一样；为了符合调用规定 可以将this传进去这样

inline 相当于把内联函数写在调用内联函数处 编译器处理步骤：将inline函数体复制到调用处，优点：省去了参数压入帧、栈帧开辟回收 结果返回等。
       本质：以代码膨胀为代价，消除函数调用带来的开销。相对于宏来说，在代码展开时候 会做安全检查或者自动类型转换。
	   虚函数可以是内敛函数吗？ 可以 但是虚函数表现为多态性时候不能内敛。运行时候多态 不可以内敛。类内定义，隐式内联 类外定义，需要显式内联

volatile
volatile int i = 10，类型修饰符 用它表面的类型变量可以被某些编译器位置的更改。使用关键字告诉编译器不应对这样的对象进行优化。
用 volatile修饰的变量。每次访问都必须从内存中取出值。

#pragrama pack(n)
设定结构体、联合、以及类成员变量以n字节方式对齐

class和struct的区别：
    （1）struct默认继承访问权限公有的，class是private的
	（2）struct作为数据结构的实现体，默认数据访问控制是public的 class默认访问控制是private的
explicit（显式）关键字
     explicit 修饰构造函数时，可以防止隐式转换和复制初始化
     explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外

friend：能访问私有成员，破坏封装性，不可传递 单向性

enum 枚举类型  enum class open_modes { input, output, append };

左右值引用：


初始化成员列表：（1）少了一次调用默认构造函数的过程；
                （2）有些场合必须使用初始化列表，常量成员 只能初始化。不能赋值，所以必须放到初始化列表中。
				   继承类可以显式的调用base带参的构造函数。初始化列表。
总结如下：（1）初始化列表无法直接初始化基类的数据成员，因此需要在列表中指定基类的构造函数、如果不指定 会调用基类的默认构造函数。
          （2）比函数体内初始化派生类成员更快，因为在分配内存后，函数体内有多进行了一次赋值操作。

多态：定义一个父类指针并且调用函数时候，实际上是调用的指针指向的实际类型，动态绑定
静态多态：函数重载
       动态多态：virtual函数，
	   Q1：静态函数为什么不是虚函数？ 静态成员函数可以看作一个命名空间受限的普通函数，说白了和类实列没有什么关系，调用时候也不会因式传this
	                                  不能有运行时候多态。


		代码区  funa funb  全体对象共有。
		堆  vptr
		虚函数表指针vptr； 通过对象内存中的vptr找到虚函数表vtabl，接着通过vtable找到对应虚函数的实现区域并进行调用。

	   Q2：构造函数是为对象内存做初始化操作的，完成之前 vptr是没有值的，也就无法通过vptr找到作为虚函数的构造函数所在的代码区。
	        虚析构函数：在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。防止内存泄漏


			没有出现覆盖父类的虚函数是没有意义的，当继承出现时候，子类若没有覆盖父类，则排着头往后面写
			1：一般继承 子类的虚函数表里面 基类的将会被覆盖，其中若子类没有虚函数则和爸爸共用一张表，若有自己的  则他们也有单独的表了 并且各自的虚指针
			   指向这个表。需要从各自类的虚函数表中查找对应的函数地址。
			2：多重继承  继承了三个爸 则把指针都集成过来，子类的虚成员函数被放到第一个父类的表中。
			3：菱形继承  数据冗余 二义性 因此出现了虚继承 

malloc free new与delete区别
           1：new底层调用了malloc分配了内存，调用构造函数。
           2：delete 调用析构函数，底层free空间  
		   3：new时候申请内存时候会自动计算所需字节数，malloc需要自己输入申请内存空间字节数


智能指针：
   