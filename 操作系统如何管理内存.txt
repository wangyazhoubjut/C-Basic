call 入口地址 
编译时候重定位   嵌入式卫星  放内存固定位置
载入时候 重定位   灵活 浪费时间 载入时候内存会法生变化
引出了
运行时候重定位  地址翻译 PCB存放了 基地址， 基地+偏移

内存中找到空闲内存首地址
创建进程及PCB pcb放入首地址 执行翻译

1000和2000地址 都放到pcb里面
执行1000 取值运行，翻译  基地址+偏移地址
switch 切换到进程2 地址基地址+偏移地址

问题：将整个程序都放入载入内存中？

每个段各自特点 将各段放入内存

PCB里面放每个段的基地址 每个进程都有一个段表

程序每个段找到空闲地方  段基地址放到表中 载入内存

将LDT表  段名称-段地址 赋给PDB 根据基+偏移 定位到物理内存。
一段一段放进来 取地址执行吧
切换 维护多个LDT表 放到进程PCB中  运行时候重定位  编译时候分为多个段

二： 内存分区 及分页
如何寻找内存的空闲区域？


 1：固定分区
 2：可变分区  空闲分区表  段请求分配


 分区效率不高： 内存碎片
 将面包分成片 将内存分为页

 物理内存固定大小分页 浪费小 空间利用率高
 每个段放在多个页中  建立多个页表
 提高利用率  页表应该小 这样会导致逻辑页表项很大啊 

 页表很大 1000000页表 每个进程都有4M页表好大啊 上百个进程呢？造成内存浪费
 根据 逻辑页  找到物理页 映射 

 多级页表  页目录加页表


 段页映射：

 程序分段 将段放到一个假的地址空间（虚拟内存），将虚拟内存分成固定大小的页 
 然后将虚拟分页映射到物理内存中。

 场景如下：程序代码段 给到虚拟内存去存放，虚拟地址打成内存页 映射成物理内存页

 根据段表的段基址+偏移 找到虚拟地址，根据页号+偏移 找到物理地址

 用户：段  物理内存：页
 分配段、建段表，分配页 建页表
 （1）分配虚存 建段表
 （2）公用父进程内存 建立页表
 （3）









